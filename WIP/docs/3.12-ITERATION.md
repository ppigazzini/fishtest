# Iteration plan (Milestone 12 — Hardening, route idiom evaluation, and Pydantic assessment)

Date: 2026-02-12
Status: Phase 6 complete — parity gap remediation implemented and validated

## Delta Update (2026-02-13): Cookie termination parity audit

Scope: compare legacy Pyramid cookie termination behavior with current Starlette HTTP behavior, for all cookie classes used by UI/session flows.

### Cookie inventory (termination semantics)

| Cookie class | Legacy Pyramid behavior | Starlette behavior before fix | Starlette behavior after fix |
|---|---|---|---|
| Auth/session login cookie (default login, no “stay logged in”) | Session cookie (no `Max-Age`, browser-session lifetime) | Session cookie (no `Max-Age`) | Unchanged |
| Auth/session login cookie (“stay logged in”) | 1 year persistence (`max_age=60*60*24*365`) | 1 year `Max-Age`, no explicit `Expires` | 1 year `Max-Age` + explicit `Expires` |
| Logout / forced clear cookie | Immediate invalidation (expired cookie) | `Expires` in past, no explicit `Max-Age=0` | `Max-Age=0` + `Expires` in past |
| UI preference cookies (`theme`) | JS-set, 30 days | Same | Same |
| UI preference cookies (`machines_state`, `tasks_state`) | JS-set, 1 hour | Same | Same |
| UI preference cookies (`master_only`, table toggle state) | JS-set, 10 years | Same | Same |

### Difference found

- Termination metadata parity gap was in Starlette middleware header formatting for persistent and cleared session cookies:
    - persistent cookie had relative expiry (`Max-Age`) but not explicit absolute date (`Expires`);
    - cleared cookie had past `Expires` but no explicit `Max-Age=0`.

### Fix applied

- Updated `server/fishtest/http/session_middleware.py`:
    - `_build_cookie_header()` now emits both `Max-Age` and RFC-compliant `Expires` for persistent cookies.
    - `_delete_cookie_header()` now emits both `Max-Age=0` and past `Expires` for clear operations.
- Updated `server/tests/test_http_boundary.py` assertions:
    - remember flow now asserts `Expires=` is present with `Max-Age`.
    - forget flow now asserts both `max-age=0` and `expires=`.

### Validation (2026-02-13)

- Targeted impacted tests: `python -m unittest -q tests.test_http_boundary tests.test_http_ui_session_semantics` → **OK**.
- HTTP lint: `ruff check server/fishtest/http` → **All checks passed**.

## Delta Update (2026-02-13, re-audit): Upstream Pyramid vs FastAPI cookie durations

Scope: re-check upstream code in `___fishtest/server/fishtest` against current FastAPI codepaths and templates, with emphasis on reported “>12 months vs 1 month” browser observations.

### Re-audit result

- **No expiry mismatch found** between upstream Pyramid behavior and current FastAPI behavior for equivalent cookie types.
- The observed ~1 month cookie is the `theme` UI preference cookie (`30 * 24 * 60 * 60`), and this is the same in upstream and FastAPI.

### Verified cookie matrix (upstream vs FastAPI)

| Cookie | Upstream Pyramid | FastAPI | Status |
|---|---|---|---|
| Auth/session (login without “stay logged in”) | Session cookie | Session cookie | Match |
| Auth/session (login with “stay logged in”) | 1 year (`60*60*24*365`) | 1 year (`Max-Age=31536000`) | Match |
| Logout/session clear | Expired clear cookie | `Max-Age=0` + past `Expires` | Match |
| `theme` | 30 days | 30 days | Match |
| `machines_state` | 1 hour | 1 hour | Match |
| `tasks_state` | 1 hour | 1 hour | Match |
| `master_only` | 10 years | 10 years | Match |
| run-table toggle state (`*_state`) | 10 years | 10 years | Match |

### Runtime verification snapshot (FastAPI)

- Login without stay flag: cookie emitted **without** `Max-Age` (session cookie).
- Login with stay flag: cookie emitted with `Max-Age=31536000` and `Expires` ~ +1 year.
- Logout: cookie emitted with `Max-Age=0` and `Expires=Thu, 01 Jan 1970 00:00:00 GMT`.

### Validation

- Focused cookie/session tests:
    - `python -m unittest -q tests.test_http_boundary tests.test_http_ui_session_semantics tests.test_http_users` → **OK**.
- Broad HTTP suite:
    - `python -m unittest discover -q -s tests -p 'test_http*.py'` → **1 unrelated failure** (`test_http_api.test_auto_purge_runs`).
- Lint:
    - `ruff check server/fishtest/http` → **All checks passed**.

### Browser evidence after cache clear (user-verified)

Conclusion from live browser capture: cookie end dates are now correct and consistent with expected semantics.

#### Pyramid (tests.stockfishchess.org)

| Cookie | Value (short) | Domain | Path | Expires | Notes |
|---|---|---|---|---|---|
| `active_state` | `Hide` | `tests.stockfishchess.org` | `/` | `2027-03-20T15:27:25.977Z` | Lax |
| `failed_state` | `Hide` | `tests.stockfishchess.org` | `/` | `2027-03-20T15:27:26.505Z` | Lax |
| `finished_state` | `Hide` | `tests.stockfishchess.org` | `/` | `2027-03-20T15:27:25.180Z` | Lax |
| `machines_state` | `Hide` | `tests.stockfishchess.org` | `/` | `2026-02-13T16:27:28.851Z` | ~1 hour |
| `paused_state` | `Hide` | `tests.stockfishchess.org` | `/` | `2027-03-20T15:27:27.269Z` | Lax |
| `pending_state` | `Hide` | `tests.stockfishchess.org` | `/` | `2027-03-20T15:27:27.799Z` | Lax |
| `session` | (auth ticket) | `tests.stockfishchess.org` | `/` | `Session` | Session cookie |
| `theme` | `dark` | `tests.stockfishchess.org` | `/` | `2026-03-15T15:27:23.134Z` | ~30 days |

#### FastAPI (dfts-0.pigazzini.it)

| Cookie | Value (short) | Domain | Path | Expires | Notes |
|---|---|---|---|---|---|
| `fishtest_session` | (signed payload) | `dfts-0.pigazzini.it` | `/` | `Session` | HttpOnly + Secure |
| `machines_state` | `Hide` | `dfts-0.pigazzini.it` | `/` | `2026-02-13T16:26:55.219Z` | ~1 hour |
| `theme` | `dark` | `dfts-0.pigazzini.it` | `/` | `2026-03-15T15:26:15.747Z` | ~30 days |
| `user_active_state` | `Hide` | `dfts-0.pigazzini.it` | `/` | `2027-03-20T15:26:48.114Z` | long-lived UI state |
| `user_failed_state` | `Hide` | `dfts-0.pigazzini.it` | `/` | `2027-03-20T15:26:47.162Z` | long-lived UI state |
| `user_finished_state` | `Hide` | `dfts-0.pigazzini.it` | `/` | `2027-03-20T15:26:50.601Z` | long-lived UI state |
| `user_paused_state` | `Hide` | `dfts-0.pigazzini.it` | `/` | `2027-03-20T15:26:57.543Z` | long-lived UI state |
| `user_pending_state` | `Hide` | `dfts-0.pigazzini.it` | `/` | `2027-03-20T15:26:56.415Z` | long-lived UI state |

Interpretation: the “1 month” observation maps to `theme` (expected 30 days), while long-lived state cookies remain >12 months where intended.


## Goals

- Fix all high and medium-priority open issues from the M11 report (93-CLAUDE-M11-REPORT.md Section 9).
- Evaluate whether the `_VIEW_ROUTES` data-driven registration model should be replaced with idiomatic `@router.get/post` decorators for `http/views.py`.
- Assess whether Pydantic introduction would provide real value given the existing vtjson validation model, and document the recommendation.
- Harden the middleware stack: convert the last `BaseHTTPMiddleware` user to pure ASGI.
- Improve the Jinja2 environment safety: replace `MakoUndefined` with `StrictUndefined`.
- Add targeted integration tests for the session middleware.
- Document parity similarity trend expectations per milestone.

## Non-goals

- No feature-level Jinja2 template redesign (M10 complete); only minimal safety fixes allowed when required by StrictUndefined.
- No DB adapter or scheduling redesign.
- No worker protocol shape changes.
- No `tests/pyramid/` stub deletion (kept for rebase).
- No broad Pydantic migration (assessment only; any adoption deferred to M N-1).
- No `_ViewContext` removal (evaluation documented; execution requires Pyramid twin retirement).
- No route file-spread (routes stay in `http/api.py` and `http/views.py`).

## Requirements

- Protocol parity preserved at all times (worker API + UI flows).
- Contract tests and parity scripts remain the safety net.
- `api.py` and `views.py` stay in upstream endpoint order with the same logical flow.
- Hop count ≤ 1 per endpoint; helper calls ≤ 2 per endpoint.
- Event loop stays thin (blocking work in threadpool).
- Cookie/CSRF/flash semantics unchanged.

## References

- Roadmap: [WIP/docs/3-MILESTONES.md](3-MILESTONES.md)
- Iteration rules: [WIP/docs/3.0-ITERATION-RULES.md](3.0-ITERATION-RULES.md)
- Architecture: [WIP/docs/2-ARCHITECTURE.md](2-ARCHITECTURE.md)
- Async inventory: [WIP/docs/2.1-ASYNC-INVENTORY.md](2.1-ASYNC-INVENTORY.md)
- M11 iteration plan: [WIP/docs/3.11-ITERATION.md](3.11-ITERATION.md)
- M11 report: [WIP/docs/93-CLAUDE-M11-REPORT.md](93-CLAUDE-M11-REPORT.md)
- FastAPI references: [WIP/docs/6-FASTAPI-REFERENCES.md](6-FASTAPI-REFERENCES.md)
- Starlette references: [WIP/docs/7-STARLETTE-REFERENCES.md](7-STARLETTE-REFERENCES.md)
- Rebase strategy: [WIP/docs/5-REBASE.md](5-REBASE.md)
- Current views: [server/fishtest/http/views.py](../../server/fishtest/http/views.py)
- Current api: [server/fishtest/http/api.py](../../server/fishtest/http/api.py)
- Current middleware: [server/fishtest/http/middleware.py](../../server/fishtest/http/middleware.py)
- Current jinja: [server/fishtest/http/jinja.py](../../server/fishtest/http/jinja.py)
- Current schemas: [server/fishtest/schemas.py](../../server/fishtest/schemas.py)
- Current boundary: [server/fishtest/http/boundary.py](../../server/fishtest/http/boundary.py)
- Bloat branch middleware: [\_\_fishtest-bloat/server/fishtest/web/middleware.py](../../__fishtest-bloat/server/fishtest/web/middleware.py)

---

## Current State Inventory (post-M11)

### HTTP Layer Summary

| Module | Lines | Purpose |
|--------|-------|---------|
| `http/views.py` | 2,793 | 29 UI endpoints, `_ViewContext`, `_dispatch_view()`, `_VIEW_ROUTES` |
| `http/api.py` | 780 | 20 API endpoints (decorators), `ApiRequestShim` thin adapter |
| `http/boundary.py` | 336 | API adapter, session commit, template context, auth helpers |
| `http/session_middleware.py` | 255 | Pure ASGI session middleware (`itsdangerous`) |
| `http/middleware.py` | 213 | 3 pure ASGI + 1 `BaseHTTPMiddleware` |
| `http/jinja.py` | 205 | Jinja2 env + `static_url` global + render helpers |
| `http/cookie_session.py` | 180 | Dict-backed session wrapper (CSRF, flash, auth) |
| `http/errors.py` | 145 | Exception handlers (API/UI error shaping) |
| `http/dependencies.py` | 92 | FastAPI dependency injection (DB handles) |
| `http/template_renderer.py` | 73 | Jinja2 renderer singleton |
| `http/ui_errors.py` | 67 | UI 404/403 rendering |
| `http/settings.py` | 62 | Environment variable parsing |
| `http/ui_context.py` | 53 | `UIRequestContext` dataclass |
| `http/csrf.py` | 48 | CSRF validation helpers |
| `http/ui_pipeline.py` | 22 | `apply_http_cache()` helper |
| `http/template_helpers.py` | 1,272 | Shared template helpers (stats, formatting) |
| **Total** | **6,603** | **17 files** |

### Retained Adapters (intentional, from M11)

| Construct | Location | Lines | Why Retained |
|-----------|----------|-------|--------------|
| `_ViewContext` | `views.py` L89–144 | ~55 | Data carrier for `_dispatch_view()`. 28 view functions access `request.session`, `request.rundb`, etc. |
| `ApiRequestShim` | `boundary.py` L47–100 | ~53 | Thin adapter for `WorkerApi`/`UserApi` domain classes. 14 unique attributes, 63 total accesses. |

### Route Registration Asymmetry

| Layer | Pattern | Count | Shared dispatch? |
|-------|---------|-------|------------------|
| `views.py` | `_VIEW_ROUTES` list + `_make_endpoint()` + `router.add_api_route()` | 29 routes (28 via `_dispatch_view`, 1 direct) | Yes: `_dispatch_view()` centralizes 11 concerns |
| `api.py` | `@router.get/post()` decorators | 20 endpoints | No: each creates `WorkerApi`/`UserApi` inline |

### Middleware Stack (current)

| Middleware | Type | Status |
|-----------|------|--------|
| `FishtestSessionMiddleware` | Pure ASGI | ✅ OK |
| `ShutdownGuardMiddleware` | Pure ASGI | ✅ OK |
| `RejectNonPrimaryWorkerApiMiddleware` | Pure ASGI | ✅ OK |
| `AttachRequestStateMiddleware` | Pure ASGI | ✅ OK |
| `RedirectBlockedUiUsersMiddleware` | Pure ASGI | ✅ OK |

---

## Key Decisions (with pros/cons analysis)

### Decision 1: Route registration — `_VIEW_ROUTES` list vs `@router.get/post` decorators

The question: should `http/views.py` move from the data-driven `_VIEW_ROUTES` list (M11 model) to idiomatic `@router.get/post` decorators, as `http/api.py` already uses?

#### Current model (M11)

```python
_VIEW_ROUTES = [
    (home, "/", _ViewCfg(direct=True)),
    (_tests, "/tests", _ViewCfg(template="tests.html.j2")),
    # ... 29 entries
]

def _register_view_routes():
    for fn, path, cfg in _VIEW_ROUTES:
        methods = _normalize_methods(cfg.get("request_method"))
        endpoint = fn if cfg.get("direct") else _make_endpoint(fn, cfg)
        router.add_api_route(path, endpoint, methods=methods, include_in_schema=False)
```

`_make_endpoint()` wraps each view function in an `async def endpoint(request)` that calls `_dispatch_view(fn, cfg, request, path_params)`. The dispatcher handles 11 cross-cutting concerns.

#### Hypothetical decorator model

```python
@router.get("/tests")
async def tests(request: Request, ctx: UIContextDep):
    result = await run_in_threadpool(_tests_impl, ctx)
    return await _render_response(request, ctx, "tests.html.j2", result)
```

Each endpoint would need to:
1. Declare dependencies for session, DB handles, CSRF, etc.
2. Construct _ViewContext (or receive its fields directly)
3. Call the sync view function in threadpool
4. Handle redirect returns
5. Render templates
6. Commit session
7. Apply HTTP cache headers
8. Apply response headers

**Option A — Keep `_VIEW_ROUTES` + `_dispatch_view()` (status quo)**

Pros:
- Centralized cross-cutting concerns: 11 concerns handled once in `_dispatch_view()`, not repeated in 28 endpoints.
- Adding a new route = 1 line in `_VIEW_ROUTES` + 1 view function. No boilerplate.
- Data-driven list is machine-parseable: parity script (`parity_check_views_routes.py`) already parses it to verify route coverage.
- Structural comparability with legacy `views.py` preserved (same endpoint order, same logical flow).
- `_dispatch_view()` is the proven pattern from M1–M11 (7 phases, zero regressions).
- API endpoints (`api.py`) don't use this pattern because they have no shared dispatch concerns — they each construct `WorkerApi`/`UserApi` inline. The asymmetry is intentional, not accidental.

Cons:
- Non-idiomatic: FastAPI's intended pattern is decorator-based route registration.
- Routes are not self-documenting: you must cross-reference `_VIEW_ROUTES` with the view function to understand the full endpoint.
- `_dispatch_view()` at 55 lines is a one-hop indirection — acceptable but not zero.
- The data-driven list is unfamiliar to FastAPI newcomers.

**Option B — Convert to `@router.get/post` decorators + FastAPI dependencies**

Would require decomposing `_dispatch_view()` into:
- A `UIContextDep = Depends(get_ui_context)` for session + DB handles + _ViewContext construction
- A CSRF dependency for POST endpoints with `require_csrf`
- A primary-instance guard dependency for `require_primary` endpoints
- A `_render_response()` helper for template rendering + session commit + cache + headers

Pros:
- Idiomatic FastAPI: each endpoint declares its contract in its signature.
- Each endpoint is self-documenting (decorator shows path, method; params show dependencies).
- `app.routes` and `router.routes` enumerate all routes at startup (already true with `add_api_route()`).
- Aligns `views.py` with `api.py` pattern.

Cons:
- **Boilerplate explosion**: 28 dispatched endpoints × ~8–12 lines of plumbing each = ~224–336 lines of new boilerplate, replacing the centralized `_dispatch_view()` + `_make_endpoint()` + `_VIEW_ROUTES` (~80 lines total).
- `views.py` would grow from 2,793 to ~2,950–3,050 lines (net +150–250 lines).
- Each endpoint would need `ctx: UIContextDep` + `_render_response()` call → this is exactly the bloat pattern (90-CLAUDE-REPORT.md flagged `UIContextDep` everywhere as a readability hazard).
- Breaks structural comparability with legacy `views.py` (significant rebase churn).
- Parity script `parity_check_views_routes.py` would need rewriting to scan decorators instead of parsing `_VIEW_ROUTES`.
- The 11 cross-cutting concerns would either be scattered across endpoints (violating DRY) or hidden behind a `_render_response()` helper (recreating the same indirection with different syntax).
- `_dispatch_view()` works perfectly. There are zero known bugs in 7 phases of proven use.

**Option C — Hybrid: decorators for new routes, list for existing**

Use `@router.get/post` for any new endpoints added post-M12, keep `_VIEW_ROUTES` for the existing 29.

Pros:
- Zero churn on existing routes.
- New developers can use familiar decorator patterns for new work.
- Gradual migration is possible if the team decides to convert later.

Cons:
- Two registration patterns in one file makes the codebase harder to understand.
- The `_dispatch_view()` cross-cutting concerns would still need to be duplicated for decorator-registered routes (or new routes would lack session/CSRF/template handling).
- Inconsistency is a maintenance hazard.

**Recommendation: Option A — Keep `_VIEW_ROUTES` + `_dispatch_view()`.**

Rationale:
1. `_dispatch_view()` is not a shim — it is a centralized cross-cutting-concern handler that prevents 28 endpoints from each duplicating 11 concerns. This is good engineering regardless of framework idiom.
2. The asymmetry with `api.py` is intentional: API endpoints have no shared dispatch concerns (no templates, no CSRF, no session commit flow), so they don't need a dispatcher. UI endpoints do.
3. Option B would produce exactly the "UIContextDep + _render_response() everywhere" pattern that the bloat analysis (90-CLAUDE-REPORT.md) identified as harmful.
4. `add_api_route()` and `@router.get()` are functionally identical (confirmed from FastAPI vendor source: `@router.get(path)` → `api_route(path, methods=["GET"])` → `add_api_route(path, func, methods=["GET"])`). Using `add_api_route()` is not less idiomatic — it is the same underlying mechanism.
5. The data-driven `_VIEW_ROUTES` list provides machine-parseability that decorators do not — the parity script already relies on this.
6. The proven track record (0 regressions across M1–M11) argues against replacing a working pattern for style reasons.

**Action**: Document this decision. No code changes for route registration.

---

### Decision 2: Pydantic — does it add value alongside vtjson?

**Summary:** vtjson and Pydantic solve different problems and are not interchangeable. vtjson validates existing Python objects (dicts, MongoDB documents) against declarative schemas with cross-field logic (`ifthen`, `cond`, `intersect`, `lax`). Pydantic deserializes raw data into typed model instances (`BaseModel`). Fishtest's validation needs are overwhelmingly in the domain layer (rundb, actiondb, etc.), not at the API boundary. Pydantic is not adopted. See Milestone N-1 in `3-MILESTONES.md` for the role comparison table and closure rationale.

The question: should Pydantic be introduced for API request body parsing, supplementing the vtjson validation currently used in `schemas.py` and `api.py`?

#### Current validation model

`schemas.py` defines 19 vtjson schemas using 37 imported vtjson functions. The API layer uses vtjson validation at 3 call sites:

```python
# In WorkerApi (server/fishtest/api.py)
validate(api_access_schema, self.request_body)    # L116 — username/password + worker_info
validate(api_schema, self.request_body)            # L144 — full request body
# In WorkerApi.upload_pgn
validate(gzip_data)                                # L295 — compression validation
```

Validation failures are caught as `ValidationError` and routed through `GenericApi.handle_error()`:

```python
def handle_error(self, error, status_code=400):
    raise HTTPException(
        status_code=status_code,
        detail=self.add_time({"error": error}),  # adds "duration" field
    )
```

The error response shape is: `{"detail": {"error": "path: message", "duration": 0.001}}` at HTTP **400**.

#### vtjson complexity profile

| Complexity | Schema Count | Examples |
|-----------|-------------|----------|
| Simple | 10 | `user_schema`, `worker_schema`, `kvstore_schema`, `api_access_schema` |
| Medium | 4 | `results_schema`, `pgns_schema`, `books_schema`, `worker_info_schema_*` |
| Complex | 3 | `nn_schema`, `api_schema`, `action_schema` (16-branch `cond`) |
| Very Complex | 1 | `runs_schema` (~100 lines, 6 cross-field validators, `ifthen`/`intersect`/`lax` chains) |

Key vtjson features with no direct Pydantic equivalent:
- `lax(schema)`: validates against `schema` but ignores extra fields. Pydantic requires `model_config = {"extra": "allow"}` per sub-model.
- `cond(predicate, schema_true, schema_false)`: conditional validation within 16-branch union. Maps to `@model_validator` with complex branching logic — far more verbose.
- `intersect(schema1, schema2, ...)`: all schemas must match. Pydantic has no built-in intersection validator; requires `@model_validator(mode="after")` chains.
- `ifthen(pred, schema)`: conditional requirement. Pydantic `@model_validator` with manual conditional logic.
- `set_name(name, schema)` / `set_label(label, schema)`: error message customization. Pydantic requires custom `ValidationError` construction.

**Option A — Keep vtjson (status quo)**

Pros:
- Zero migration effort.
- vtjson's cross-field validators (`ifthen`, `cond`, `intersect`, `lax`) handle fishtest's complex validation patterns concisely.
- Only 3 validation call sites in `api.py` — the scope of vtjson usage in the HTTP layer is small and well-contained.
- Error format (`{"error": "...", "duration": N}` at 400) is established protocol with the worker. No risk of format change.
- vtjson schemas double as documentation: the schema structure mirrors the data shape closely.
- No new dependency.

Cons:
- No type safety: validated data remains `dict` with string-key access (`body["worker_info"]["username"]`).
- No auto-deserialization into typed objects.
- No OpenAPI schema generation from validation rules.
- vtjson is a niche library — less community familiarity than Pydantic.

**Option B — Introduce Pydantic for API request bodies**

Would require:
- Creating Pydantic models for `api_access_schema`, `api_schema`, and `runs_schema`.
- Overriding FastAPI's default `RequestValidationError` handler to produce `{"error": "...", "duration": N}` at status 400 (not the default 422).
- Keeping vtjson for the complex schemas (`runs_schema`, `action_schema`) that use features with no Pydantic equivalent.

Pros:
- Typed request bodies: `body.worker_info.username` instead of `body["worker_info"]["username"]`.
- Auto-deserialization by FastAPI (less manual `await request.json()` + `validate()` plumbing).
- OpenAPI schema generation (if the API is ever published).
- Industry-standard validation library with large community.

Cons:
- **Cross-field validators cannot be migrated.** `runs_schema` (the most critical schema, ~100 lines, 6 cross-field validators) uses `ifthen`, `intersect`, `lax`, `cond`, `at_most_one_of` — none of these have concise Pydantic equivalents. Attempting to express them as `@model_validator(mode="after")` chains would produce 200+ lines of verbose Python replacing 100 lines of declarative vtjson.
- **Error format requires custom handler.** FastAPI default is 422 with `[{"loc": [...], "msg": "...", "type": "..."}]`. Workers expect 400 with `{"error": "...", "duration": N}`. A custom `app.add_exception_handler(RequestValidationError, ...)` is needed — adding complexity rather than reducing it.
- **Dual validation layer.** vtjson cannot be fully replaced (the complex schemas are impractical to rewrite). Keeping both vtjson and Pydantic means two validation systems in the codebase — worse than one.
- **Only 3 call sites.** The API layer's vtjson usage is minimal. Migrating 3 call sites to Pydantic while keeping the complex schemas in vtjson creates inconsistency with little benefit.
- **`lax` pattern has no clean Pydantic equivalent.** vtjson's `lax(schema)` ignores extra fields during conditional matching. Pydantic's `extra="allow"` is model-wide and changes the model's behavior globally, which may surface unexpected field leakage in downstream code.
- **26/29 UI endpoints don't use JSON body validation.** They parse HTML forms. Pydantic models help with JSON, not form data. The scope of benefit is narrow: 20 API endpoints, of which only 9 POST endpoints use JSON body validation.

**Option C — Pydantic for new API endpoints only**

Introduce Pydantic models only for newly added API endpoints (post-M12). Keep existing vtjson validation for all current endpoints.

Pros:
- No migration effort on existing code.
- New endpoints get type safety and auto-parsing.
- Gradual adoption.

Cons:
- Two validation systems in the codebase (vtjson for existing, Pydantic for new).
- New endpoints still need the custom error handler to match the worker-facing error format.
- Fishtest rarely adds new API endpoints — this may never trigger.

**Recommendation: Option A — Keep vtjson as sole validation layer.**

Rationale:
1. vtjson and Pydantic solve different problems. vtjson validates existing Python objects against declarative schemas; Pydantic deserializes raw data into typed models. The codebase needs the former, not the latter.
2. vtjson's cross-field validators (`ifthen`, `cond`, `intersect`, `lax`) are heavily used and have no concise Pydantic equivalents. The most critical schema (`runs_schema`, ~100 lines) would balloon to 200+ lines as Pydantic `@model_validator` chains. `action_schema` (16-branch `cond`) would need 16 model classes + a discriminated union.
3. Only 3 validation call sites exist at the API boundary. The other ~12+ call sites are in the domain layer (`rundb`, `actiondb`, `userdb`, etc.) — Pydantic cannot help there.
4. The worker error format (`{"error": "...", "duration": N}` at 400) is established protocol. Pydantic's default 422 behavior must be overridden, adding complexity rather than reducing it.
5. Introducing Pydantic for simple schemas while keeping vtjson for complex ones creates a dual-validation layer — two systems are worse than one.
6. No public OpenAPI schema documentation is planned. The API serves internal workers, not external consumers.

**Action**: Document this decision. Update M N-1 milestone with role comparison and closure rationale. No Pydantic introduction.

---

### Decision 3: `RedirectBlockedUiUsersMiddleware` — pure ASGI conversion

The question: should the last `BaseHTTPMiddleware` user be converted to pure ASGI?

**Context**: M11 converted 3 middleware to pure ASGI but kept `RedirectBlockedUiUsersMiddleware` on `BaseHTTPMiddleware` because it needed session access. Now that `FishtestSessionMiddleware` populates `scope["session"]`, it can read session data directly from the ASGI scope.

**Option A — Convert to pure ASGI**

```python
class RedirectBlockedUiUsersMiddleware:
    def __init__(self, app: ASGIApp) -> None:
        self.app = app

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
        session = scope.get("session", {})
        # Check blocked status and redirect if needed
        ...
        await self.app(scope, receive, send)
```

Pros:
- Eliminates the last `BaseHTTPMiddleware` in the stack.
- `BaseHTTPMiddleware` is deprecated in Starlette docs for new code.
- Pure ASGI supports streaming responses and avoids contextvars propagation issues.
- Consistent with the other 3 middleware (all pure ASGI).

Cons:
- Slightly more complex ASGI plumbing for the redirect response construction.
- Performance gain is negligible (blocked users are rare).
- Risk is low but nonzero — pure ASGI must handle `scope`, `receive`, `send` correctly.

**Option B — Keep `BaseHTTPMiddleware`**

Pros:
- Already working.
- Simpler code (~50 lines).
- Low risk.

Cons:
- Starlette `BaseHTTPMiddleware` is deprecated for new code.
- Inconsistent with the other 3 pure ASGI middleware.
- Blocks streaming responses (not relevant here, but a principle concern).

**Recommendation: Option A — Convert to pure ASGI.**

Rationale: The blocker (session access in ASGI scope) was removed by M11's `FishtestSessionMiddleware`. The conversion is straightforward (~2h effort), low risk, and eliminates a deprecated pattern. The bloat branch already has a reference implementation. Consistency with the existing pure ASGI middleware is valuable.

---

### Decision 4: `MakoUndefined` → `StrictUndefined`

The question: should the Jinja2 environment's undefined behavior change from `MakoUndefined` (renders `"UNDEFINED"` for missing variables) to `StrictUndefined` (raises `UndefinedError`)?

**Context**: `MakoUndefined` was introduced during dual-renderer (Mako + Jinja2) transition to avoid template crashes when context keys differed between engines. Template context coverage is now clean — zero Jinja2 undefined-variable issues (`template_context_coverage.py` confirms).

**Option A — Replace with `StrictUndefined`**

Pros:
- Safer for production: missing context variables raise an error instead of rendering silently as `"UNDEFINED"`.
- `StrictUndefined` is the Jinja2 community recommendation for production environments.
- Context coverage is clean — no templates reference undefined variables.
- Catches future regressions immediately (a missing context key crashes, not silently renders garbage).

Cons:
- Risk: any undiscovered template path with special context that wasn't covered by `template_context_coverage.py` would crash at runtime.
- Migration path: zero changes needed if coverage is truly complete; otherwise, a failing render in production.

**Option B — Keep `MakoUndefined`**

Pros:
- Zero risk of runtime template crashes from missing variables.
- Graceful degradation: renders `"UNDEFINED"` instead of crashing (visible in output, not a hard error).

Cons:
- Silently renders `"UNDEFINED"` text in user-visible HTML — a worse user experience than a proper error.
- No regression protection: a missing context key is a silent bug.
- The `MakoUndefined` name is a Pyramid-era artifact that should be retired.

**Recommendation: Option A — Replace with `StrictUndefined`.**

Rationale: Template context coverage is verified clean. `StrictUndefined` is the idiomatic Jinja2 production choice. The risk is bounded — if an undiscovered path exists, it would surface as a `500 Internal Server Error` which is immediately detectable (vs silently rendering `"UNDEFINED"` text in HTML, which may go unnoticed). The `MakoUndefined` name itself is a Pyramid-era carryover.

---

## Phases

### Phase 0 — Inventory and test baseline

Checklist:
- [x] Run full contract test suite and record baseline pass/fail.
- [x] Run all parity scripts and record baseline.
- [x] Verify `template_context_coverage.py` shows zero Jinja2 missing keys.
- [x] Measure `RedirectBlockedUiUsersMiddleware` current line count and session access pattern.
- [x] Confirm `FishtestSessionMiddleware` populates `scope["session"]` before `RedirectBlockedUiUsersMiddleware` executes (middleware ordering in `app.py`).

#### Phase 0 Results

**Test baseline**:
- `python -m unittest discover -s tests -q` runs in this environment but Mongo-backed suites are not locally runnable (no local Mongo service), and emit expected `MongoClient` resource warnings during class setup.
- Runnable baseline captured via `bash WIP/tools/run_local_tests.sh` (full local suite with timeout): **187 passed, 0 failed**.

**Parity + coverage baseline**:

| Script | Result |
|--------|--------|
| `parity_check_api_routes.py` | **OK** — normalized API endpoint coverage/methods good |
| `parity_check_views_routes.py` | **OK** — 29/29 routes matched, 0 method mismatches |
| `parity_check_api_ast.py` | **OK** — 0 changed bodies, 2 expected drifts (`api_download_pgn`, `api_download_run_pgns`) |
| `parity_check_views_ast.py` | **OK** — 0 changed bodies, 36 expected drifts, 1 expected missing (`notfound_view`) |
| `parity_check_hotspots_similarity.py` | **views=0.7171, api=0.7535** (both above 0.65 threshold) |
| `parity_check_urls_dict.py` | **OK** — all 22 URL mappings match |
| `compare_template_parity.py` | **OK** — normalized parity equal across templates |
| `template_context_coverage.py` | **OK** — Jinja coverage clean; Mako missing keys are expected and ignored |

**Middleware/session inventory**:
- `server/fishtest/http/middleware.py` line count: **213**.
- `RedirectBlockedUiUsersMiddleware` remains `BaseHTTPMiddleware` and uses `dispatch()` + `load_session(request)` pattern.
- `create_app()` middleware registration order (add order):
    1. `ShutdownGuardMiddleware`
    2. `AttachRequestStateMiddleware`
    3. `RejectNonPrimaryWorkerApiMiddleware`
    4. `RedirectBlockedUiUsersMiddleware`
    5. `FishtestSessionMiddleware`

Because Starlette executes middleware in reverse add order, `FishtestSessionMiddleware` runs before `RedirectBlockedUiUsersMiddleware` on incoming requests; therefore session scope is available before blocked-user redirect logic.

#### Insights for Phase 1+

- **Phase 1 (`StrictUndefined`) is low risk**: template context coverage is clean for Jinja templates, so switching undefined behavior should be straightforward.
- **Phase 2 conversion is unblocked**: middleware ordering confirms session availability before redirect middleware, enabling pure ASGI conversion without adding a session pre-loader.
- **Baseline stability is strong**: parity scripts all green with expected drifts only, so Phase 1/2 changes can use these exact gates as regression tripwires.
- **Local test strategy updated**: run the full local suite (Mongo-backed included) with timeout using `bash WIP/tools/run_local_tests.sh`.

### Phase 1 — Replace `MakoUndefined` with `StrictUndefined`

Target: `server/fishtest/http/jinja.py`

Checklist:
- [x] Change `undefined=MakoUndefined` to `undefined=StrictUndefined` in the Jinja2 environment configuration.
- [x] Remove `MakoUndefined` class/import if it becomes unused.
- [x] Run contract tests + parity scripts + template parity.
- [x] Verify no runtime template crashes via `template_context_coverage.py`.
- [x] Update this document with Phase 1 results.

Impact:
- `MakoUndefined` → `StrictUndefined` is a 1-line change.
- If `MakoUndefined` is defined locally, remove it (~5–10 lines).
- Risk mitigated by context coverage verification in Phase 0.

#### Phase 1 Results

**Code changes**:
- `server/fishtest/http/jinja.py`
    - Switched Jinja undefined behavior from `MakoUndefined` to `StrictUndefined`.
    - Removed the local `MakoUndefined` class.
- StrictUndefined surfaced latent template assumptions (optional keys referenced without defaults). Minimal compatibility hardening was applied:
    - `server/fishtest/templates_jinja2/run_table.html.j2`: added defaults for optional context keys (`toggle`, `runs`, `show_delete`, `show_gauge`, `header`, `count`, `alt`, `pages`).
    - `server/fishtest/templates_jinja2/elo_results.html.j2`: defaulted `show_gauge` to `false`.
    - `server/fishtest/templates_jinja2/nns.html.j2`: normalized `is_master` access to safe mapping/attribute fallback.

**Verification**:
- Contract baseline: `bash WIP/tools/run_local_tests.sh` → **63 passed, 0 failed** (historical Phase 1 run).
- Lint:
    - `bash WIP/tools/lint_http.sh` → **All checks passed**.
    - `bash WIP/tools/lint_tools.sh` → **All checks passed**.
- Parity scripts:
    - `parity_check_api_routes.py` → **OK**.
    - `parity_check_views_routes.py` → **OK**.
    - `parity_check_api_ast.py` → **OK** (2 expected drifts only).
    - `parity_check_views_ast.py` → **OK** (expected drift/missing only).
    - `parity_check_hotspots_similarity.py` → **views=0.7171, api=0.7535**.
    - `parity_check_urls_dict.py` → **OK**.
- Template verification:
    - `compare_template_parity.py` → **OK** (all templates normalized-equal).
    - `template_context_coverage.py` → **OK** for Jinja (Mako missing keys expected/ignored).

#### Insights for Phase 2+

- `StrictUndefined` immediately catches hidden optional-context assumptions, which is positive hardening; future template work should keep explicit defaults for optional keys.
- The middleware/route parity metrics stayed unchanged (`views=0.7171`, `api=0.7535`), confirming Phase 1 was behavior-preserving.
- Phase 2 remains unblocked: with Phase 1 complete and gates green, `RedirectBlockedUiUsersMiddleware` conversion can proceed with the same regression net.
- The docs now diverge from old guidance that suggested lenient runtime undefined behavior; when Phase 4 docs are updated, align older Jinja references to the new StrictUndefined runtime reality.

### Phase 2 — Convert `RedirectBlockedUiUsersMiddleware` to pure ASGI

Target: `server/fishtest/http/middleware.py`

Checklist:
- [x] Convert `RedirectBlockedUiUsersMiddleware` from `BaseHTTPMiddleware` to pure ASGI `__call__`.
- [x] Read session from `scope["session"]` instead of constructing a `Request` object.
- [x] Construct `RedirectResponse` and call `await response(scope, receive, send)` for redirect.
- [x] Remove the `BaseHTTPMiddleware` import if no longer used.
- [x] Run contract tests + parity scripts + lint http.
- [x] Update this document with Phase 2 results.

#### Phase 2 Results

**Code changes**:
- `server/fishtest/http/middleware.py`
    - Converted `RedirectBlockedUiUsersMiddleware` to pure ASGI middleware (`__init__` + `__call__`).
    - Removed dependency on `BaseHTTPMiddleware` and `dispatch()` for blocked-user redirects.
    - Switched blocked-user session lookup from `Request` + `load_session()` to direct `scope["session"]` access.
    - Used `authenticated_user_from_data(session_data)` for username extraction from ASGI session payload.
    - Preserved redirect semantics by constructing `RedirectResponse(url="/tests", status_code=302)` and sending via `await response(scope, receive, send)`.
    - Preserved forced cookie clearing by setting `scope["session_force_clear"] = True` after invalidating session data.

**Verification**:
- Contract baseline: `bash WIP/tools/run_local_tests.sh` → **63 passed, 0 failed** (historical Phase 2 run).
- Parity scripts:
    - `parity_check_api_routes.py` → **OK**.
    - `parity_check_views_routes.py` → **OK**.
    - `parity_check_api_ast.py` → **OK** (2 expected drifts only).
    - `parity_check_views_ast.py` → **OK** (expected drift/missing only).
    - `parity_check_hotspots_similarity.py` → **views=0.7171, api=0.7535**.
    - `parity_check_urls_dict.py` → **OK**.
- Template verification:
    - `compare_template_parity.py` → **OK** (all templates normalized-equal).
    - `template_context_coverage.py` → **OK** for Jinja (Mako missing keys expected/ignored).
- Lint:
    - `bash WIP/tools/lint_http.sh` → **All checks passed**.
    - `bash WIP/tools/lint_tools.sh` → **All checks passed**.

#### Insights for Phase 3+

- The final `BaseHTTPMiddleware` user is removed; middleware stack is now consistently pure ASGI for request-path concerns.
- Blocked-user redirect behavior remains parity-safe: session invalidation, forced cookie clear, and `/tests` redirect all preserved.
- Similarity metrics remained stable (`views=0.7171`, `api=0.7535`), confirming the Phase 2 change was structural hardening without behavioral drift.
- Phase 3 can now focus on session integration tests without middleware model churn.

Reference: bloat branch pure ASGI middleware implementations in `__fishtest-bloat/server/fishtest/web/middleware.py`.

### Phase 3 — Add custom HTTP integration tests (Mongo-backed + session)

Target: new test file or enhancement to existing test files in `server/tests/`.

Checklist:
- [x] Add useful integration tests for custom HTTP files now that Mongo is available locally:
    - `test_http_middleware.py`: blocked-user redirect with real Mongo `userdb` and non-blocked pass-through path.
    - `test_http_boundary.py`: `commit_session_flags(... forget=True ...)` clears cookie and `build_template_context()` reflects pending-user count.
- [x] Run these tests locally.
- [x] Run the full local suite (Mongo-backed included) with timeout via `run_local_tests.sh`.
- [x] Update this document with Phase 3 results.

#### Phase 3 Results

**Code changes**:
- Added 2 Mongo-backed middleware integration tests in `server/tests/test_http_middleware.py`:
    - `test_redirect_blocked_ui_users_with_real_userdb`
    - `test_allows_non_blocked_ui_user_with_real_userdb`
- Added 2 boundary/session integration tests in `server/tests/test_http_boundary.py`:
    - `test_session_forget_flags_force_cookie_clear`
    - `test_template_context_pending_users_count`

**Validation**:
- Targeted test run:
    - `python -m unittest -v tests.test_http_middleware tests.test_http_boundary`
    - Result: **14 passed, 0 failed**.
- Full local suite run (Mongo-backed + timeout):
    - `bash WIP/tools/run_local_tests.sh` (uses `timeout ${TEST_TIMEOUT_SECONDS:-900}`)
    - Result: **187 passed, 0 failed**.

**Notes**:
- `WIP/tools/run_local_tests.sh` is the local full-suite runner.
- Phase 3 is complete.

### Phase 4 — Low-priority improvements (evaluation outcomes)

These items were evaluated to closure in M12. Outcomes are either "won't do" (with rationale) or "done".

Checklist:
- [x] Evaluate splitting `template_helpers.py` (1,272 lines) into `template_helpers.py` (~450 lines) + `template_stats.py` (~800 lines). Only proceed if the split reduces cognitive load without increasing hop count.
- [x] Consider generating the `urls` dict in `build_template_context()` from `router.routes` at startup instead of maintaining a hardcoded mapping. Verify parity with `parity_check_urls_dict.py`.
- [x] Consider Starlette `context_processors` for base template context injection (replaces some of `build_template_context()` logic).
- [x] Add parity trend tracking tool: record views/api similarity scores per milestone and display trend.
- [x] Update this document with Phase 4 results.

#### Phase 4 Results

- `template_helpers.py` split (`template_helpers.py` + `template_stats.py`) is **won't do** for M12: this is a style refactor with no demonstrated safety/maintainability gain for current call sites. Keeping one pure-function module avoids churn during rebase-sensitive stabilization.
- `urls` dict generation from `router.routes` is **won't do**: explicit mapping remains the source of truth for template-facing URL keys and keeps `parity_check_urls_dict.py` deterministic.
- Starlette `context_processors` migration is **won't do**: current `build_template_context()` is centralized, explicit, and auditable; introducing context processors would add indirection without reducing observed duplication.
- Parity trend tracking is **done** in this document (`Appendix D`) and remains the milestone-over-milestone similarity record.
- Phase 4 is complete as an evaluation/decision phase (no production code changes required).

### Phase 5 — Documentation and deployment notes

Target: documentation files in `WIP/docs/`.

Checklist:
- [x] Add deployment note: M11 invalidates all sessions (cookie format changed from HMAC-SHA256 to `itsdangerous.TimestampSigner`). All users will be logged out on deployment. No migration code needed. Include in a visible location for operators.
- [x] Document parity similarity expected ranges per milestone in `3-MILESTONES.md`.
- [x] Update M N-1 description in `3-MILESTONES.md` with vtjson/Pydantic role comparison and closure rationale (they solve different problems; no Pydantic adoption planned).
- [x] Record route registration decision (Option A: keep `_VIEW_ROUTES`) in architecture docs.
- [x] Record Pydantic assessment decision (Option A: keep vtjson) in architecture docs.
- [x] Update this document with Phase 5 results.

#### Phase 5 Results

- Deployment note recorded: session cookie format changed in M11; deployment invalidates all existing sessions and forces re-login (accepted operationally).
- `3-MILESTONES.md` updated with M12 status/progress and explicit Pydantic guidance in M N-1.
- `2-ARCHITECTURE.md` updated with two explicit architectural decisions:
    - keep `_VIEW_ROUTES` + `_dispatch_view()` route registration model,
    - keep vtjson as the validation source of truth (no broad Pydantic adoption).
- Validation gates re-run in this phase:
    - Full local tests: `bash WIP/tools/run_local_tests.sh` → **187 passed, 0 failed**.
    - Lint scripts: `bash WIP/tools/lint_http.sh` and `bash WIP/tools/lint_tools.sh` → **all checks passed**.
    - Parity scripts: `api_routes`, `views_routes`, `api_ast`, `views_ast`, `hotspots`, `urls_dict` → **OK**.
    - Hotspots similarity snapshot: **views=0.7171**, **api=0.7528**.
    - Template parity + context coverage: `compare_template_parity.py` and `template_context_coverage.py` → **OK** (expected Mako-side ignored misses only).
- Phase 5 is complete.

### Phase 6 — Parity gap remediation (from function-by-function audit)

Date: 2026-02-12
Status: complete

Phase 6 closed the actionable parity gaps from the function-by-function audit and recorded the remaining items as intentional drift.

#### Implemented changes

- `server/fishtest/http/api.py`
    - Added missing structural parity stub: `class InternalApi(GenericApi): pass` (GAP-1).
    - Removed unreachable `assert match is not None` in `download_run_pgns()` (GAP-2).
    - Removed dead `GenericApi.parse_page_param()` and `parse_unix_timestamp()` methods (GAP-3).
    - Added comments documenting explicit `OPTIONS` handlers as intentional preflight support (GAP-4).
- `server/fishtest/http/views.py`
    - Added explicit docstring to `ensure_logged_in()` documenting return-based redirect contract (GAP-5).
    - Verified `validate_modify()` docstring already reflects return-based contract (GAP-9).
- `server/fishtest/app.py`
    - Added optional `SIGUSR1` all-thread dump registration via `faulthandler.register(signal.SIGUSR1, all_threads=True)` with safe fallback logging (GAP-12).
- `server/fishtest/http/middleware.py`
    - Confirmed one-shot `_base_url_set` fallback is already implemented in `AttachRequestStateMiddleware` (`rundb.base_url` is set from first request host/scheme when unset), resolving GAP-10.
- `WIP/tools/parity_check_api_ast.py`
    - Improved parity tooling to assert required class-presence parity (`InternalApi`) in addition to endpoint method-body parity.

#### Verification results

- Lint:
    - `bash WIP/tools/lint_http.sh` → **all checks passed**
    - `bash WIP/tools/lint_tools.sh` → **all checks passed**
- Tests:
    - `bash WIP/tools/run_local_tests.sh` → **187 passed, 0 failed**
- Parity scripts:
    - `uv run python WIP/tools/parity_check_api_ast.py` → **OK** (0 drift, expected streaming drifts only)
    - `uv run python WIP/tools/parity_check_views_ast.py` → **OK** (expected drift/missing only)
    - `uv run python WIP/tools/parity_check_hotspots_similarity.py` → **views=0.7164, api=0.7604** (both above 0.65 threshold)
    - `server/.venv/bin/python WIP/tools/compare_template_response_parity.py` → **OK** (20 expected normalized diffs, 0 hard mismatches)
    - `server/.venv/bin/python WIP/tools/compare_jinja_mako_parity.py` → **OK** (wrapper now mirrors expected-diff informational mode)

#### Gap closure status

| Gap | Status | Note |
|-----|--------|------|
| GAP-1 | ✅ Closed | `InternalApi` restored |
| GAP-2 | ✅ Closed | dead assert removed |
| GAP-3 | ✅ Closed | dead helpers removed |
| GAP-4 | ✅ Closed | explicit preflight behavior documented in code |
| GAP-5 | ✅ Closed | `ensure_logged_in()` contract documented |
| GAP-6 | ℹ️ Intentional | FastAPI URL generation uses path literals (documented) |
| GAP-7 | ℹ️ Intentional | Jinja context reshaping (filters dict) |
| GAP-8 | ℹ️ Intentional | pre-formatted context replacing template function |
| GAP-9 | ✅ Closed | docstring already accurate; verified |
| GAP-10 | ✅ Closed | base URL fallback already active in middleware |
| GAP-11 | ✅ Closed | shutdown parity covered by lifespan `_shutdown_rundb()` |
| GAP-12 | ✅ Closed | SIGUSR1 handler added |

#### Documentation sync

- Updated in this phase: `1-FASTAPI-REFACTOR.md`, `2-ARCHITECTURE.md`, `3-MILESTONES.md`, and this file.

#### Post-phase regression incident (2026-02-12, fixed)

Incident summary:
- A production UI regression surfaced after the FastAPI template-request cleanup and StrictUndefined hardening.
- Error seen in logs: `jinja2.exceptions.UndefinedError: 'starlette.requests.Request object' has no attribute 'authenticated_userid'` while rendering `tests_view.html.j2`.

Root cause:
- `tests_view.html.j2` still referenced Pyramid-era template access (`request.authenticated_userid`).
- Runtime now passes a plain Starlette `Request` object in template context; that object has no `authenticated_userid` attribute.
- StrictUndefined correctly raised an exception instead of silently rendering.

Fix:
- `server/fishtest/templates_jinja2/tests_view.html.j2`
    - Replaced `request.authenticated_userid` with `current_user`-based check:
        - `follow == 1 and current_user and run["args"]["username"] == current_user["username"]`.

Full sweep (slow/full audit) to prevent repeats:
- Exhaustive scan across `server/fishtest/templates_jinja2/*.j2` for `request.*` usage and Pyramid-only attributes.
- Result: no remaining Pyramid-only `request.<attr>` references.
- Remaining runtime `request` references are only `request.url` (valid on Starlette `Request`) in:
    - `nn_upload.html.j2`
    - `tests_run.html.j2`
    - `user.html.j2`

Verification after fix:
- `server/.venv/bin/python -m unittest -q tests.test_http_users` → **OK**.
---

## Verification gates (per phase)

From `server/`:
- `uv run python -m unittest discover -s tests -q`
- Or from repo root: `bash WIP/tools/run_local_tests.sh` (full suite, timeout guarded)

Lint:
- `WIP/tools/lint_http.sh`
- `WIP/tools/lint_tools.sh`

Parity scripts (from repo root):
- `uv run python WIP/tools/parity_check_api_routes.py`
- `uv run python WIP/tools/parity_check_views_routes.py`
- `uv run python WIP/tools/parity_check_api_ast.py`
- `uv run python WIP/tools/parity_check_views_ast.py`
- `uv run python WIP/tools/parity_check_hotspots_similarity.py`
- `server/.venv/bin/python WIP/tools/parity_check_urls_dict.py`
- One-command wrapper: `WIP/tools/run_parity_all.sh`
- Strict wrapper mode: `WIP/tools/run_parity_all.sh --strict`

Template parity:
- `server/.venv/bin/python WIP/tools/compare_template_parity.py`
- `server/.venv/bin/python WIP/tools/template_context_coverage.py`

## "Stop the line" conditions

- Worker response shape changes (especially `duration` field).
- UI errors start returning JSON instead of HTML.
- Cookie/session breaks login persistence, flashes, or CSRF.
- Blocking work moves onto the event loop.
- Parity hotspot similarity drops below 0.65 for `views.py` or `api.py`.
- Any new file created under `http/` that splits routes or adds a new router.
- Template context coverage shows new Jinja2 missing keys after `StrictUndefined` switch.

---

## Success metrics

| Metric | M11 Final | Target (M12) |
|--------|-----------|-------------|
| `BaseHTTPMiddleware` users | 1 | 0 |
| Jinja2 `undefined` class | `MakoUndefined` | `StrictUndefined` |
| Session integration tests | 0 | ≥ 5 |
| Deployment note for session migration | Missing | Present |
| Parity similarity expected ranges documented | No | Yes |
| Route registration decision documented | No | Yes (Option A: keep `_VIEW_ROUTES`) |
| Pydantic assessment documented | No | Yes (Option A: keep vtjson) |
| Contract tests | 63 pass, 0 fail | 63+ pass, 0 fail |
| Parity similarity (views) | 0.7171 | ≥ 0.70 |
| Parity similarity (api) | 0.7535 | ≥ 0.74 |
| Route files | 2 | 2 |
| Hop count per endpoint | ≤ 1 | ≤ 1 |
| Helper calls per endpoint | ≤ 2 | ≤ 2 |

---

## Appendix A: `_dispatch_view()` Cross-Cutting Concerns Inventory

The centralized dispatcher handles 11 distinct concerns for 28 of 29 UI endpoints:

| # | Concern | Lines | Why Centralized |
|---|---------|-------|-----------------|
| 1 | Context/session extraction | 2 | Every UI endpoint needs DB handles and session |
| 2 | POST form parsing | 4 | Size limits (`max_files`, `max_fields`, `max_part_size`) enforced uniformly |
| 3 | CSRF enforcement | 3 | Applied to all `require_csrf` endpoints |
| 4 | `_ViewContext` construction | 1 | Provides typed access to session, DB handles, params, auth |
| 5 | Primary-instance guard | 6 | POST + `require_primary` → 503 Service Unavailable |
| 6 | Threadpool dispatch | 1 | Sync view functions run off the event loop |
| 7 | Redirect handling | 3 | `RedirectResponse` returns get session commit + headers |
| 8 | Template rendering | 6 | `render_template_to_response()` with `build_template_context()` |
| 9 | Session commit | 1 | `commit_session_response()` for remember/forget cookie logic |
| 10 | HTTP cache | 1 | `apply_http_cache(response, cfg)` |
| 11 | Response headers | 1 | `_apply_response_headers(shim, response)` |

Total: ~29 lines of concern handling that would be duplicated across 28 endpoints if the dispatcher were removed.

## Appendix B: vtjson Schema Complexity Detail

### Most complex: `runs_schema` (~100 lines)

Cross-field validators:
1. `final_results_must_match`: validates result counts sum correctly
2. `cores_must_match`: validates cores allocation consistency
3. `valid_aggregated_data`: validates aggregated data integrity
4. `at_most_one_of("sprt", "spsa")`: mutual exclusion
5. `ifthen(keys("sprt"), sprt_schema)`: conditional SPRT schema application
6. `lax(intersect(keys(...), validator))`: extra-field-tolerant intersection

Pydantic equivalent estimate: 200–250 lines of `@model_validator(mode="after")` chains.

### Second most complex: `action_schema` (16-branch `cond`)

The `cond` validator branches on `action` field value:
```python
cond(
    {"action": "failed_task"},    task_result_schema,
    {"action": "upload_nn"},      nn_action_schema,
    {"action": "modify_run"},     modify_run_schema,
    # ... 16 total branches
)
```

Pydantic equivalent: 16 separate model classes + a discriminated union on `action` field + custom error handling. Estimate: 150+ lines replacing ~60 lines of vtjson.

## Appendix C: `api.py` Route Registration Pattern (for comparison)

`api.py` uses idiomatic `@router.get/post` decorators with no shared dispatch:

```python
@router.post("/api/request_task", include_in_schema=False)
async def api_request_task(request: Request):
    api = WorkerApi(await get_request_shim(request))
    return await run_in_threadpool(api.request_task)
```

This pattern works for API endpoints because they:
- Don't render templates (return JSON directly)
- Don't need CSRF enforcement (API uses bearer auth)
- Don't need session commit flow (stateless API)
- Don't need HTTP cache headers (dynamic data)
- Share only the `WorkerApi`/`UserApi` construction pattern (1 line per endpoint)

The UI dispatch pattern is fundamentally different: 11 shared concerns vs 1.

## Appendix D: Parity Similarity Trend

| Milestone | views.py | api.py | Notes |
|-----------|----------|--------|-------|
| M10 (baseline) | 0.7473 | 0.6991 | Pre-shim removal |
| M11 Phase 1 | 0.7405 | 0.6991 | After decorator/exception shim removal |
| M11 Phase 5 | 0.7178 | 0.7535 | After all shim phases + AST normalization |
| M11 Final | 0.7171 | 0.7535 | After Phase 7 cleanup |
| M12 Final | 0.7164 | 0.7604 | Phase 6 remediation + parity tooling normalization |
| M12 expected | 0.70–0.72 | 0.74–0.76 | Infrastructure changes only |
