# Async boundaries inventory (event loop vs threadpool)

Date: 2026-02-12

Goal: make it unambiguous what runs on the ASGI **event loop** vs what runs in a
**threadpool** (i.e. “async wrapper around sync code”). This inventory is based
on the active code under `server/fishtest/`.

## Entrypoint matrix (one-screen view)

| Component | Event-loop work (should be quick) | Threadpooled work | Remaining loop CPU hotspots |
|---|---|---|---|
| Lifespan startup/shutdown | Orchestration + `asyncio.sleep(0.5)` | `RunDb(...)`, GitHub init, scheduler stop, cache flush/save, Mongo close | None known |
| Middleware dispatch | Request-state/session plumbing; small checks | Blocked-user DB lookup + caching | None known |
| API route wrappers | Parse body; construct shims; `await` threadpool results | All `WorkerApi`/`UserApi` handler bodies | JSON decoding in `await request.json()` |
| UI dispatch | Parse form; CSRF checks; route plumbing | Sync view bodies + Jinja2 template rendering | Form parsing in `await request.form()` |
| Error handlers | Route-to-UI-vs-API decision; small JSON shaping | UI template rendering (via UI helpers) | None known |

## Legend

- **[LOOP]** Runs on the event loop (inside `async def`). Must be fast.
- **[THREAD]** Runs in a worker thread via `run_in_threadpool(...)`.
- **[STREAM/THREAD]** Streaming iteration in a thread via `iterate_in_threadpool(...)`.
- **[CPU/LOOP]** CPU work that still happens on the loop (e.g. JSON/form parsing).

Notes:

- “`async def`” ≠ “non-blocking”. It only means “awaitable entrypoint”.
- In this codebase, most heavy work is sync and is explicitly offloaded.

---

## 1) Application lifespan (startup/shutdown)

File: [server/fishtest/app.py](../../server/fishtest/app.py)

Async entrypoint:

- **[LOOP]** `lifespan()` (FastAPI lifespan context manager)
  - Startup:
    - **[LOOP]** `AppSettings.from_env()` (env parsing; small)
    - **[LOOP]** `_require_single_worker_on_primary(settings)` (env check; small)
    - **[THREAD]** `RunDb(...)` via `run_in_threadpool(RunDb, ...)`
    - Primary-only:
      - **[THREAD]** `gh.init(...)`
      - **[THREAD]** `rundb.update_aggregated_data()`
      - **[THREAD]** `rundb.schedule_tasks()`
  - Shutdown:
    - **[LOOP]** `rundb._shutdown = True` + `await asyncio.sleep(0.5)`
    - **[THREAD]** `rundb.scheduler.stop()` (if present)
    - **[THREAD]** `rundb.run_cache.flush_all()` / `rundb.save_persistent_data()` (primary only)
    - **[THREAD]** `rundb.actiondb.system_event(...)` (if `port >= 0`)
    - **[THREAD]** `rundb.conn.close()`

Event-loop blocking risk (current):

- No known I/O blocking on loop; the only loop work is small orchestration + sleep.

---

## 2) Middleware dispatch

File: [server/fishtest/http/middleware.py](../../server/fishtest/http/middleware.py)
      [server/fishtest/http/session_middleware.py](../../server/fishtest/http/session_middleware.py)

Async entrypoints:

- **[LOOP]** `FishtestSessionMiddleware.__call__()`
  - Pure ASGI middleware.
  - Decodes the session cookie into `scope["session"]` via `itsdangerous.TimestampSigner`.
  - On response, re-encodes the session and applies per-request flags (`session_max_age`, `session_secure`, `session_force_clear`).
  - Enforces cookie size limits; trims flash queues if necessary.

- **[LOOP]** `ShutdownGuardMiddleware.__call__()`
  - Pure ASGI middleware.
  - Checks `request.app.state.rundb._shutdown` and returns 503 if set.

- **[LOOP]** `AttachRequestStateMiddleware.__call__()`
  - Pure ASGI middleware.
  - Sets `request.state.request_started_at`.
  - Attaches `rundb`, `userdb`, `actiondb`, `workerdb` to `request.state`.
  - Sets `rundb.base_url` once using request headers.

- **[LOOP]** `RejectNonPrimaryWorkerApiMiddleware.__call__()`
  - Pure ASGI middleware.
  - Checks if request path matches a primary-only API endpoint and the instance is not primary; returns 503 if so.

- **[LOOP]** `RedirectBlockedUiUsersMiddleware.__call__()`
  - Pure ASGI middleware.
  - **[LOOP]** Reads session data directly from `scope["session"]`.
  - **[THREAD]** Blocked-user lookup via `_get_blocked_cached_async()`.
  - If blocked: clears session, sets `scope["session_force_clear"]`, redirects to `/tests`.

Event-loop blocking risk (current):

- Blocked-user DB call is offloaded; remaining loop work is small.

---

## 3) API router: async wrappers + sync handler bodies

File: [server/fishtest/http/api.py](../../server/fishtest/http/api.py)

Key boundary idea:

- Route functions are `async def`, but the handler bodies (`WorkerApi` / `UserApi`
  methods) run in a threadpool.

Async helper:

- **[CPU/LOOP]** `_make_request_shim(request)`
  - **[CPU/LOOP]** `await request.json()` parses JSON in-process.
    - Reading the body is async, but JSON decoding is CPU work on the loop.

Worker routes (threadpooled handler bodies):

- **[LOOP]** `POST /api/request_task` → **[THREAD]** `WorkerApi.request_task()`
- **[LOOP]** `POST /api/update_task` → **[THREAD]** `WorkerApi.update_task()`
- **[LOOP]** `POST /api/failed_task` → **[THREAD]** `WorkerApi.failed_task()`
- **[LOOP]** `POST /api/stop_run` → **[THREAD]** `WorkerApi.stop_run()`
- **[LOOP]** `POST /api/request_version` → **[THREAD]** `WorkerApi.request_version()`
- **[LOOP]** `POST /api/beat` → **[THREAD]** `WorkerApi.beat()`
- **[LOOP]** `POST /api/request_spsa` → **[THREAD]** `WorkerApi.request_spsa()`
- **[LOOP]** `POST /api/worker_log` → **[THREAD]** `WorkerApi.worker_log()`
- **[LOOP]** `POST /api/upload_pgn` → **[THREAD]** `WorkerApi.upload_pgn()`

User routes (threadpooled handler bodies):

- **[LOOP]** `GET /api/rate_limit` → **[THREAD]** `UserApi.rate_limit()`
- **[LOOP]** `GET /api/active_runs` → **[THREAD]** `UserApi.active_runs()`
- **[LOOP]** `GET /api/finished_runs` → **[THREAD]** `UserApi.finished_runs()`
- **[LOOP]** `POST /api/actions` → **[THREAD]** `UserApi.actions()`
- **[LOOP]** `GET /api/get_run/{id}` → **[THREAD]** `UserApi.get_run()`
- **[LOOP]** `GET /api/get_task/{id}/{task_id}` → **[THREAD]** `UserApi.get_task()`
- **[LOOP]** `GET /api/get_elo/{id}` → **[THREAD]** `UserApi.get_elo()`
- **[LOOP]** `GET /api/calc_elo` → **[THREAD]** `UserApi.calc_elo()`
- **[LOOP]** `GET /api/pgn/{id}` → **[THREAD]** `UserApi.download_pgn()`
- **[LOOP]** `GET /api/run_pgns/{id}` → **[THREAD]** `UserApi.download_run_pgns()`
- **[LOOP]** `GET /api/nn/{id}` → **[THREAD]** `UserApi.download_nn()`

Streaming boundary:

- Inside **[THREAD]** `UserApi.download_pgn()` / `download_run_pgns()`:
  - Returns `StreamingResponse(iterate_in_threadpool(_iter_filelike(...)))`.
  - This makes the file-like read loop **[STREAM/THREAD]**.

Event-loop blocking risk (current):

- JSON decode in `_make_request_shim` is the primary remaining CPU-on-loop hotspot.

---

## 4) UI router and dispatch

File: [server/fishtest/http/views.py](../../server/fishtest/http/views.py)

Key boundary idea:

- UI endpoints are `async def` wrappers that do small request parsing / CSRF checks
  on-loop, then run legacy sync view functions + Mako rendering in a threadpool.

Async entrypoints:

- **[LOOP]** `render_notfound_response(request)`
  - **[THREAD]** Template rendering via `run_in_threadpool(render_template, ...)`.
  - Commits cookie session.

- **[LOOP]** `render_forbidden_response(request)`
  - **[THREAD]** Template rendering via `run_in_threadpool(render_template, ...)`.
  - Commits cookie session.

- **[LOOP]** `_dispatch_view(fn, cfg, request, path_params)` (central UI dispatcher)
  - **[CPU/LOOP]** `await request.form()` parses form data in-process.
  - **[LOOP]** CSRF validation (`csrf_or_403`), token extraction.
  - **[THREAD]** Executes view function `fn(...)` via `run_in_threadpool`.
  - **[THREAD]** Template rendering via `run_in_threadpool(render_template_to_response, ...)`.

Event-loop blocking risk (current):

- Form parsing (`request.form()`) can be CPU-heavy for large payloads.

---

## 5) Error handlers

File: [server/fishtest/http/errors.py](../../server/fishtest/http/errors.py)

Async entrypoints:

- **[LOOP]** `_http_exception_handler()`
  - For UI paths: delegates to UI renderers (which threadpool template rendering).

- **[LOOP]** `_request_validation_handler()`
  - Builds JSON error payloads for API/worker routes.

- **[LOOP]** `_unhandled_exception_handler()`
  - Returns JSON errors for API/worker routes; plain text for UI routes.

Event-loop blocking risk (current):

- UI error pages template-render in a threadpool; API errors are pure JSON.

---

## Summary: what still runs on the event loop?

- Small orchestration / request-state plumbing in lifespan + middleware.
- Session cookie decode/encode in `FishtestSessionMiddleware` (HMAC + base64 + JSON; small payloads).
- **[CPU/LOOP]** `request.json()` decode in API `_make_request_shim`.
- **[CPU/LOOP]** `request.form()` parsing in UI `_dispatch_view`.

Everything else intentionally heavy (DB, scheduler, view bodies, template rendering,
file reads) is explicitly offloaded.

## Async concurrency model

The ASGI event loop decouples connection acceptance from handler execution:

| Metric | Description |
|--------|-------------|
| Max concurrent connections | Thousands (limited by OS/memory, not threads) |
| Threads consumed per idle connection | 0 (coroutine frame, ~KBs) |
| Overload behavior | Connections queue in kernel backlog (`--backlog 2048`) |
| Event loop dispatch latency | Microsecond-scale |
| Blocking work isolation | Explicit (`run_in_threadpool`) |

This means:

1. **Connection acceptance is not the bottleneck.** Uvicorn holds open
   thousands of HTTP connections on the event loop while only a handful
   simultaneously occupy threadpool slots for blocking MongoDB/lock work.
2. **Do not use `--limit-concurrency`.**  This Uvicorn flag **rejects**
   excess connections with HTTP 503 (plain text). Workers receiving a
   non-JSON response enter exponential backoff (15 s → 900 s). Connections
   should queue in the kernel backlog instead.
3. **Worker fleet scaling**: 10,000+ workers can all maintain heartbeat and
   task-fetch connections. The application-level `task_semaphore(5)` and
   `request_task_lock` are the governing throttle for the scheduling
   critical path.

---

## Runtime invariants

File: [server/fishtest/app.py](../../server/fishtest/app.py)

- Primary instances must run with a single Uvicorn worker.
- Enforced by `_require_single_worker_on_primary()` when `UVICORN_WORKERS` or
  `WEB_CONCURRENCY` is set to a value other than `1`.
