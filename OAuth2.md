
# Project: OAuth2 Web Login (GitHub + Google) with Password Fallback

## Goal

Add OAuth2 login for the *web interface only* using GitHub and Google, while keeping the existing username/password login as a fully supported fallback.

Non-goals:
- Do not change worker authentication or API authentication.
- Do not remove or weaken existing password login.

## Scope

- Web UI: Add “Sign in with GitHub” and “Sign in with Google” on the login page.
- Server: Add OAuth2 routes/handlers, profile fetching, account linking/creation.
- Persistence: Store OAuth identities on the existing user records.
- Security: State/CSRF protection, safe post-login redirects.

## Approach

### 1) Understand existing authentication

- Confirm Pyramid uses `AuthTktAuthenticationPolicy` + `remember()`/`forget()`.
- Confirm `/login` and `/signup` behavior:
	- Password-based login should continue to work as-is.
	- Newly created accounts are `pending` (manual approval) and cannot log in until approved.

### 2) Choose OAuth2 library

- Use Authlib (`authlib`) as the OAuth2 client library (actively maintained, modern).
- Keep the integration minimal and Pyramid-agnostic:
	- Build auth URLs
	- Exchange code for token
	- Fetch user profile + verified email

### 3) Add OAuth routes (web only)

- Add routes:
	- `GET /oauth/login/{provider}`
	- `GET /oauth/callback/{provider}`

- `/oauth/login/{provider}`
	- Validate provider ∈ {github, google}.
	- Generate a random `state` and store in session.
	- Store safe “next” URL in session.
	- Redirect to provider authorization endpoint.

- `/oauth/callback/{provider}`
	- Validate `state` matches session value.
	- Exchange `code` for access token.
	- Fetch profile:
		- GitHub: `/user` plus `/user/emails` to get a verified email.
		- Google: OpenID Connect userinfo endpoint.
	- Normalize into (minimal): `sub`, `email`, `email_verified`, `login`.

### 4) Link or create local user accounts

Rules:
- If (provider, sub) already linked → login that user.
- Else if `email_verified` is true and a local user with that email exists → link this OAuth identity to that user.
- Else create a new local user:
	- Set `pending=True` to match existing anti-spam/manual-approval behavior.
	- Set a strong random password (not disclosed) so password login remains available for *existing* password users, and OAuth users can later add/change password via future UI if desired.

Persistence (minimal personal data):
- Extend the user schema to support optional fields under `oauth.github` / `oauth.google`:
	- `sub` (required for linked identity)
	- optional `email`, `email_verified`, `login`, `updated_at`
	- Do not store avatars/images or other profile fields.

### 5) Update login UI

- Show OAuth buttons only if provider is configured.
- Keep the existing password form unchanged and prominent.
- Add safe redirect behavior after OAuth login using the existing `next` pattern.

### 6) Configuration

Use environment variables (no secrets committed to INI or repo):
- GitHub:
	- `FISHTEST_OAUTH_GITHUB_CLIENT_ID`
	- `FISHTEST_OAUTH_GITHUB_CLIENT_SECRET`
- Google:
	- `FISHTEST_OAUTH_GOOGLE_CLIENT_ID`
	- `FISHTEST_OAUTH_GOOGLE_CLIENT_SECRET`

Redirect URIs to register in provider consoles:
- `https://<host>/oauth/callback/github`
- `https://<host>/oauth/callback/google`

#### Where to get the GitHub Client ID / Client Secret

These values come from a GitHub **OAuth App** (you create it once per environment, or a single app with multiple callback URLs if you prefer).

1. Go to GitHub → Settings → Developer settings → OAuth Apps
2. Create a **New OAuth App**
3. Set the callback URL(s) exactly:
	- PROD: `https://tests.stockfishchess.org/oauth/callback/github`
	- DEV: `https://dfts-0.pigazzini.it/oauth/callback/github`
4. After creating the app:
	- Copy **Client ID** → set `FISHTEST_OAUTH_GITHUB_CLIENT_ID`
	- Click **Generate a new client secret** → copy it → set `FISHTEST_OAUTH_GITHUB_CLIENT_SECRET`

Notes:
- The Client Secret is generated by GitHub (not something you invent).
- GitHub typically shows the full secret only at creation time; store it in your secret manager.

#### Where to get the Google Client ID / Client Secret

These values come from a Google Cloud **OAuth 2.0 Client ID** (Web application).

1. Open Google Cloud Console and select/create a project
2. Go to APIs & Services → OAuth consent screen (configure it first)
3. Go to APIs & Services → Credentials → Create credentials → OAuth client ID
4. Choose **Web application**
5. Add authorized redirect URI(s) exactly:
	- PROD: `https://tests.stockfishchess.org/oauth/callback/google`
	- DEV: `https://dfts-0.pigazzini.it/oauth/callback/google`
6. After creating the client:
	- Copy **Client ID** → set `FISHTEST_OAUTH_GOOGLE_CLIENT_ID`
	- Copy **Client secret** → set `FISHTEST_OAUTH_GOOGLE_CLIENT_SECRET`

Notes:
- The Client Secret is generated by Google (not something you invent).
- Redirect URIs must match exactly (scheme/host/path).

### 7) Security considerations

- Enforce state validation (`state` in session must match callback).
- Only allow local “next” redirects (path starting with `/`, not `//`).
- Keep OAuth strictly on the web UI endpoints; do not use OAuth to authenticate worker APIs.

### 8) Testing / validation

- Add unit tests for account linking/creation logic (no real OAuth network calls).
- Ensure existing tests for password login/signup still pass.
- Manual validation checklist:
	- Password login works.
	- OAuth login works with GitHub and Google.
	- A verified-email OAuth login links to an existing account.
	- Newly created OAuth users are pending and cannot access protected pages until approved.

## Deliverables

- New OAuth module (provider config + profile normalization).
- New Pyramid routes and views for OAuth login/callback.
- User schema updates + userdb linking helpers.
- Login page buttons.
- Tests for linking/creation.
